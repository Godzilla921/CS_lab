## 一、实验目的

本实验目的是加强学生对位级运算的理解及熟练使用的能力。

## 二、报告要求

本报告要求学生把实验中实现的所有函数逐一进行分析说明，写出实现的依据，也就是推理过程，可以是一个简单的数学证明，也可以是代码分析，根据实现中你的想法不同而异。

## 三、函数分析

1. bitXor 函数

**函数要求：**

函数名 | bitXor
-|-
参数 | int x, int y
功能实现 | x^y
要求 | 只能使用~和|运算符,将结果返回。

**实现分析：**

a^b = (a & ~b) | (~a & b)= ~((~(a&(~b)))&(~((~a)&b)))

**函数实现：**

```C
int bitXor(int x, int y) {
  return ~((~(x&(~y)))&(~((~x)&y)));
}
```

2. getByte 函数

**函数要求：**

函数名 | getByte
-|-
参数 | int x, int n 
功能实现 | 从字x中取出第n个字节
要求 | 只能使用 ! ~ & ^ | + << >> 将结果返回

**实现分析分析：**
n为要取出的字节(从左往右依次为0,1,2,3)
实现时只需将x& --ff-- ff为要取出的字节，
先将0xff左移到我们要取出的字节处(n<<3为左移的位数，因为一个字节占8为)，
然后和x与后将结果右移同样的位数，最后取出单个字节即可

**函数实现：**

```C
int getByte(int x, int n) {  //从x中取出第n个字节
  return ((x&(0xFF<<(n<<3)))>>(n<<3))&0xff;
}
```

3. logicalShift 函数

**函数要求：**

函数名 | logicalShift
-|-
参数 | int x, int n
功能实现 | 将字节x向右逻辑位移n位
要求 | 只能使用! ~ & ^ | + << >>运算符,将结果返回。

**实现分析：**

对n进行分析,若n=0,不移动，直接将结果返回，利用!n-1可以得到flag=(0x0),n非零，或(0xffffffff)n为零

flag可以作为选择子，选择直接返回x或将操作后x的返回

若n!=0 需要进行移动，由于传入的是int类型带符号数，直接右移进行的是算数右移，
这时我们只需要将右移过的数再&000……11, 0的个数即为右移的位数，

我们可以通过 将1左移32-n位然后再减去1 即可得到 000……11,再将次数&(x>>n)即可得到逻辑右移的结果

**函数实现：**

```C
int logicalShift(int x, int n) {  
  // 若n为0 直接返回x 否则返回移动后的值
  int t=~1+1;  // -1
  int flag=!n+t;
  return (~flag&x)|(((x>>n)&((0x1<<(32+(~n+1)))+t))&flag);
}
```

4. bitCount 函数

**函数要求：**

函数名 | bitCount
-|-
参数 | int x
功能实现 | 统计x二进制表示中1出现的次数
要求 | 只能使用! ~ & ^ | + << >> 将结果返回

**实现分析分析：**

x为int类型，为32为二进制数，可以将32位二进制数按4位为一组划分为8部分，先分别统计每四位中的1的个数，再将总数相加即可得到最终结果

第一步先定义变量 mask=0x11111111;

然后通过x&mask在每四位中最低位上的1，通过将x不断向右位移，依次作x&mask并将结果加入到s中

此时我们得到的s十六进制表示中8位数字之和即为x中1的个数

之后通过类似这折叠的形式，不断将左半边的数字与右半边对应数字相加
例如 s =0x23411023
例如 通过s=s+(s>>16) 将s左边的十六进制数与右边对应的相加 得到0x----3364

再令mask=0x0f0f,通过s=(s&mask)+((s>>4)&mask)  得到 0x-----6-a
最后通过  (s+(s>>8))&0x3f 得到 6+a =0x------10&0x3f 得 0x00000010=16

**函数实现：**

```C
int bitCount(int x) {
  int mask = 0x11111111;  // mask=0x11111111
  int s=x&mask;            // 
  s+=x>>1&mask;
  s+=x>>2&mask;
  s+=x>>3&mask;            // 4位一组，每一个十六进制数记录了本组中出现的1的个数
  s=s+(s>>16);             // 对s进行一次合并
  mask=0xf|(0xf<<8);
  s=(s&mask)+((s>>4)&mask);
  return (s+(s>>8))&0x3f;
}
```

5. conditional 函数

**函数要求：**

函数名 | conditional
-|-
参数 | int x,int y,int z
功能实现 | 实现三目操作x=0返回z;x!=0,返回y
要求 | 只能使用! ~ & ^ | + << >> 将结果返回

**实现分析分析：**

将x作为选择子，通过t=!x-1, 若x=0，则t=0x0; 若x!=0, 则t=0xffffffff
(t&y)|((~t)&z)

**函数实现：**

```C
int conditional(int x, int y, int z) {
  int t =!(x^0x0)+(~1)+1;  // x=0 时 t=0x0  x!=0时 t=~0x0;
  return (t&y)|((~t)&z);
}
```

6. tmin 函数

**函数要求：**

函数名 | tmin
-|-
参数 | void
功能实现 | 返回最小有符号数
要求 | 只能使用! ~ & ^ | + << >> 将结果返回

**实现分析分析：**

对于有符号数，最小为-2^(n-1)，即0x80000000,可以通过将1左移31位得到

**函数实现：**

```C
int tmin(void) {
  return 1<<31;
}
```

7. fitsBits 函数

**函数要求：**

函数名 | fitsBits
-|-
参数 | int x, int n
功能实现 |判断x是否能用n位二进制数表示
要求 | 只能使用! ~ & ^ | + << >> 将结果返回

**实现分析分析：**

判断能否用n位二进制数表示，即判断将左侧的32-n位全部阶段后是否与原数一直

move=32-n得到需要阶段的位数，先将x左移move位，然后再右移move位，判断前后结果是否一致即可

**函数实现：**

```C
int fitsBits(int x, int n) {
  int move=32+(~n+1);  // 32-n
  return !(x^((x<<move)>>move)); 
}
```

8. dividePower2 函数

**函数要求：**

函数名 | dividePower2
-|-
参数 | int x, int n
功能实现 |利用位移实现除法，并进行向0舍入
要求 | 只能使用! ~ & ^ | + << >> 将结果返回

**实现分析分析：**

首先要判断x为正数，还是负数，正数的话向右位移就是向0舍入，直接输出x>>n即可

若x为负数，x>>n做的是向下舍入，实现向0舍入我们需要加入偏置量2^n-1（n为向右的位移位数）

我们要求x>>n向上取整，不妨设x=r*2^n+q;  r即为我们要求的值，q<0
则 -2^n+1<=q<=0,令偏置bias=2^n-1,则 x+bias=r*2^n+q+2^n-1 x/(2^n)=r+(q+2^n-1)/2^n

由于-2^n+1<=q<=0 故   0<=q+2^n-1<=2^n-1 即 r<=x/(2^n)<=r+(2^n-1)/2^n=r
即向零取整

**函数实现：**

```C
int dividePower2(int x, int n) {
  int flag=((x>>31)&0x1)+(~1+1);  //判断是正数还是负数 x>=0 flag=0xffffffff,x<0 flag=0x00000000;
  return ((flag&x)|((~flag)&(x+(1<<n)+(~1+1))))>>n;
}
```

9. negate 函数

**函数要求：**

函数名 | negate
-|-
参数 | int x
功能实现 |取反函数，返回-x
要求 | 只能使用! ~ & ^ | + << >> 将结果返回

**实现分析分析：**

对于补码来说，对其取反，即将x的二进制表示取反并+1

**函数实现：**

```C
int negate(int x) {
  return ~x+1;
}
```

10. howManyBits 函数

**函数要求：**

函数名 | howManyBits
-|-
参数 | int x
功能实现 |计算最少可用多少位可以表示X
要求 | 只能使用! ~ & ^ | + << >> 将结果返回

**实现分析分析：**

对与正数来说，其所需位数为有效位数再加上一位符号位

对于负数来说，其有效位数是从左向右数第一个非1处开始，再加上符号位

故可以将负数 取反，和正数一样寻找第一个非零所在的位置，最后加上一位符号位即可

先判断高16位是否存在1，若存在1，则+16（低十六位数），并到高16位去寻找；若没有在n+=0直接到低十六位数中寻找

缩短区间后，再次去寻找高八位，看是否有1，过程类似于上述16位中的寻找

这样一层一层的逐渐缩短查找的区间，知道区间位数为1时停止；将所有n作和再加上符号位即为最终结果

n记录的是从高位到低位已经找到的1的个数

**函数实现：**

```C
int howManyBits(int x) {
  int n = 0;
  int sign=x>>31; //判断x为正数还是负数 若为负数sign为0xffffffff 若为非负数sign为 0x0
  // 若x为负数，则对x取反，找到第一个1的位置
  x=(sign&(~x))|((~sign)&x);
  n += ((!!(x&((~0x0)<<(n+16)))) << 4);  //判断高16位是否有1 有的话n+16
  n += ((!!(x&((~0x0)<<(n+8)))) << 3);   //判断高八位是否有1 有的话n+8
  n += ((!!(x&((~0x0)<<(n+4)))) << 2);   //判断高4位是否有1  有的话n+4
  n += ((!!(x&((~0x0)<<(n+2)))) << 1);   //判断高2位是否有1  有的话n+2
  n += (!!(x&((~0x0)<<(n+1))));          //判断高1位是否有1  有的话n+1
  n += (!!(x&((~0x0)<<(n))));            //判断低1位是否为1  有的话n+1
  return n+1;                            //最后加上一位符号位
}
```

11. isLessOrEqual 函数

**函数要求：**

函数名 | isLessOrEqual
-|-
参数 | int x，int y
功能实现 |比较函数，判断x是否小于等于y
要求 | 只能使用! ~ & ^ | + << >> 将结果返回

**实现分析分析：**

无法使用<=符号，但可转化为y-x 判断y-x后的结果为负数还是非负数，即判断最高位为0还是1；

若最高位为1 表示y-x<0 即x>y 返回0；若最高位为0表示y-x>=0即x<=y，返回1

但由于Int为32为数，且有一位为符号位，故可能出现数据溢出，需要额外进行判断

显然当x为负数，y为正数时x一定小于y;当x为正数，y为负数时，x一定大于y

对于这两种情况我们可以直接返回结果，无需计算

当x与y同号时，y-x必不可能溢出，直接判断y-x后的符号即可

取出x的符号s1;取出y的符号s2 s1&(!s2)即表示x为负，y为非负数，直接返回1

(s1|(!s2))表示只有当s1为正数，且s2为负数时才为0，此时x>y直接返回0
**函数实现：**

```C
int isLessOrEqual(int x, int y) {
  // // y-x>0  注意例外 当y=0x7fffffff x=0x80000000时 ~x+1=0x80000000 y+(~x+1)<0 (y<x?)
  // return (!((y+(~x+1))>>31)&0x1)|((x>>31)&(!(y>>31)));  
  int k=y+(~x+1);     // 得到y-x
  int t=(k>>31)&1;    // 得到y-x 的符号
  int s1=(x>>31)&1;   // 记录x 的符号
  int s2=(y>>31)&1;   // 记录y 的符号            抛去去x为正数，y为负数的情况
  return (s1&(!s2))|((s1|(!s2))&(!t)); // x为负数,y为非负数，直接返回1； x为负数或y为非负数并且x<=y
}
```

12. intLog2 函数

**函数要求：**

函数名 | intLog2
-|-
参数 | int x
功能实现 | 计算log2(x)
要求 | 只能使用 ! ~ & ^ | + << >> 将结果返回

**实现分析分析：**

log2(x)得到正整数，向下取整，其实就是从x二进制表示时第一个1所在的位置
算法同howManyBits先找到可以用多少位表示，例如log2(101)=2,log(1010)=3;

故只要从左向右找到第一个1的位置，再减去1就行了

```C
int intLog2(int x) {
  // x 一定为正数，需要找到首位1的下标（从右向左数）
  // 现在开始去寻找首位1
  int n = 0;
  n += ((!!(x&((~0x0)<<(n+16)))) << 4);  //判断高16位是否有1 有的话n+16
  n += ((!!(x&((~0x0)<<(n+8)))) << 3);   //判断高八位是否有1 有的话n+8
  n += ((!!(x&((~0x0)<<(n+4)))) << 2);   //判断高4位是否有1  有的话n+4
  n += ((!!(x&((~0x0)<<(n+2)))) << 1);   //判断高2位是否有1  有的话n+2
  n += (!!(x&((~0x0)<<(n+1))));          //判断高1位是否有1  有的话n+1
  n += (!!(x&((~0x0)<<(n))));            
  return n+(~1+1);                            //最后减去一位
}
```

13. floatAbsVal 函数

**函数要求：**

函数名 | intLog2
-|-
参数 | unsigned uf
功能实现 | 返回uf的绝对值
要求 | Any integer/unsigned operations incl. ||, &&. also if, while

**实现分析分析：**

float32位浮点数表示：31为符号位，31~24为阶码，23~0为小数部分

将floatfu点数取绝对值就是将符号位变为0其余31为不变即可。&7fffffff

NaN即 exp=255,frac!=0时直接返回uf本身

```C
unsigned floatAbsVal(unsigned uf) {
  if(!((uf&0x7f800000)^0x7f800000)&&(uf&0x007fffff)){ //NaN exp=256且frac!=0
    return uf;
  }
  return uf&0x7fffffff; //将最高位变为0即可
}
```

14. floatScale1d2 函数

**函数要求：**

函数名 | intLog2
-|-
参数 | unsigned uf
功能实现 | 将浮点数float*0.5
要求 | Any integer/unsigned operations incl. ||, &&. also if, while

**实现分析分析：**

float32位浮点数表示：31为符号位，31~24为阶码，23~0为小数部分

先取出 符号位sign，阶码exp以及小数部分frac

讨论特殊情况：无穷或者NaN exp都等于255，此时直接返回uf即可

exp=0时，w*。2无需考虑阶码，只需将小数部分右移一位，再加上符号位即可

小数部分右移可能会存在舍入，这里我们考虑向偶数舍入；

且只有最后两位为11时才进1，故先进行判断，若后两位为11直接先+1，再向右移

考虑规格化的浮点数：即0<exp<255; 浮点数*0.5相当于阶码减1

当exp=1时，exp-1=0；此时需要将小数部分的1加上，然后整体向右移一位，并向偶数舍入

当exp!=1时，直接将exp-1即可

最后将符号位，exp以及小数frac连接即可

```C
unsigned floatScale1d2(unsigned uf) {
  unsigned sign=uf&0x80000000;     // 取出符号位
  unsigned exp=uf&0x7f800000;      // 取出阶码
  unsigned frac=uf&0x007fffff;     // 取出小数，不带1
  if(!(exp^0x7f800000)){ //NaN&无穷都返回自身
    return uf;
  }
  if(!exp){  // 等于0 或者无穷小时 直接将小数右移 再加上符号位即可
    // 还要考虑 溢出时的摄入问题
    if(!((frac&0x3)^0x3)){  // 若最低两位为11 需要进1(即向偶数摄入)
      frac=frac+1;
    }
    return sign|(frac>>1);
  }
  // 规格化  将阶码减一即可
  exp=((exp>>23)+(~1+1))<<23;
  if(!exp){ // 若阶码减一后0
    if(!((frac&0x3)^0x3)){  // 若最低两位为11 需要进1(即向偶数摄入)
        frac=frac+1;
      }
    frac=(frac|0x00800000)>>1; // 考虑移除后的舍人问题
  }
  return sign|exp|frac;
}
```

15. floatFloat2Int 函数

**函数要求：**

函数名 | floatFloat2Int
-|-
参数 | unsigned uf
功能实现 |将float类型的数转化为Int型的整数返回
要求 | Any integer/unsigned operations incl. ||, &&. also if, while

**实现分析分析：**

float为32位的浮点数，最高位为符号位，31~24为阶码，且阶码存在偏置127，23~0为小数点右侧的数据

转化时需要先取出符号sign，阶码exp以及小数frac并上1

对exp进行判断 exp=255时为无穷数或者NaN直接返回0x80000000u即可

同时，当向左移位溢出时，也要返回0x80000000u；当exp-158>=0时左溢出

阶码为0exp=0或向右溢出时直接返回0即可，当exp<127时右溢出

当不会发生溢出时，我们将exp-127得到真正的幂次
先将frac左移7位，即到达最左边，再将frac右移30-exp位得到真正的值

最后通过符号sign进行选择，正数直接返回，负数取反加1
**函数实现：**

```C
int floatFloat2Int(unsigned uf) {
  unsigned sign=!!(uf&0x80000000)+(~1+1);   // 取出符号位 若为负数，sign位 0x0，若为正数 sign为0xffffffff
  unsigned exp=(uf&0x7f800000)>>23;         // 得到阶码
  unsigned frac=(uf&0x007fffff)|0x00800000; // 取出小数部分 并补上1
  // 注意 负数最可可以取到0x80000000
   // Nan infinite 或 左移溢出 即左移31位及以上 或为最小的负数0x80000000u
  if((!(exp^0xff))||(!((exp+(~158+1))>>31))){   // exp=255 或 exp>=158 
    return 0x80000000u;
  }
  if(!exp||((exp+(~127+1))>>31)){  // 阶码为0 或阶码小于127(exp-127<0) 直接返回0
    return 0;
  }
  exp+=~127+1;
  // 此时   0<=exp<=30 ,若exp <23 右移，exp>23 左移 exp=23不移动
  frac<<=7;// 先将frac左移7位
  frac>>=(30+(~exp+1)); // 再将frac右移30-exp位
  return (sign&frac)|((~sign)&(~frac+1));  // 若uf为负数，对其取反，正数保持不变
}
```

## 四、实验总结

通过本次实验，对于二进制位操作有了更深的了解

在实现bitCount函数时，如何不利用循环去计数是一个难题，参考了别人的方法后，学会了利用分区的方法，
先计算出每一个小区间内1的个数，再逐步“折叠”进行相加，缩小区间值，知道区间只剩一位

howManyBits函数我认为是本次实验最难的一题，关键点在于如何找到第一个非零的位置。巧妙之处在于n不仅仅用于计数，
还用来做位移操作，即当我在高16位找到1时,n=16，下一次利用n+8的位移到高16位的高8位中去寻找，依次类推。

intlog2函数的实现类似于howManyBits，找到数学规律就简单许多

floatScale1d2函数实现浮点数除以2，解决此题要对float结构有充足的理解，先取出符号位，阶码和小数，在根据不同的情况分类讨论，
另外要注意的是小数向右位移时可能会溢出，此时存在向偶数舍入的情况

floatFloat2Int函数实现浮点数转化为整数，理解float结构在解决此题就较为容易了。

